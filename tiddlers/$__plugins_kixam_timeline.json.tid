author: kixam
core-version: >=5.1.8
created: 20190509094111298
dependents: 
depends: $:/plugins/felixhayashi/vis $:/plugins/kixam/moment
description: vis.js Timeline plugin for TiddlyWiki5
list: readme usage license
modified: 20190509094111298
plugin-type: plugin
source: https://github.com/kixam/TW5-visjsTimeline
title: $:/plugins/kixam/timeline
type: application/json
version: 0.7.9

{
    "tiddlers": {
        "$:/plugins/kixam/timeline/widget.utils.js": {
            "title": "$:/plugins/kixam/timeline/widget.utils.js",
            "text": "/*\\\ntitle: $:/plugins/kixam/timeline/widget.utils.js\ntype: application/javascript\nmodule-type: library\n\n  A library of reusable functions, used in the TW5-visjsTimeline plugin\n\n\\*/\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\n\n(function() {\n  'use strict';\n\n  // parseWidgetAttributes\n  //\n  // Utility to handle configuration attributes for a widget.\n  // It handles validation, coercion and assignment of attribute values to the current widgets fields.\n  // Parent and nextSibling are required so that any errors can be reported\n  //\n  // The attributeDefns are a object representing with a field for each attribute expected by the widget\n  //\n  // Each definition field is an object with two fields\n  // type - This is used to coerce values before assignment (only string and integer are currently supported)\n  // defaultValue - When an attribute is not provided in the plugin call, then this value should be used instead\n  //\n  // If an attribute is passed to the plugin that is not expected (i.e. in the attributeDefns object), then this function returns false\n  // and an error message is output on the parent.  This should be shown instead of the widget's usual view.\n  //\n  function parseWidgetAttributes(self, attributeDefns) {\n    var errors = [];\n    for (var attr in self.attributes) {\n      if (attributeDefns[attr] === undefined) {\n        errors.push(attr);\n      } else {\n        if (attributeDefns[attr].type == \"string\") {\n          self[attr] = self.attributes[attr];\n        } else if (attributeDefns[attr].type == \"integer\") {\n          self[attr] = parseInt(self.attributes[attr] );\n          if (isNaN(self[attr])) {\n            delete self[attr];\n          }\n        }\n      }\n    }\n    if (errors.length !== 0) {\n      return errors;\n    }\n    for (var attrDefn in attributeDefns) {\n      if (self[attrDefn] === undefined) {\n        self[attrDefn] = attributeDefns[attrDefn].defaultValue;\n      }\n    }\n    return undefined;\n  }\n\n  function displayTiddler(self,toTiddlerTitle){\n    var domTiddler = self.parentDomNode.parentNode;\n    var bounds = domTiddler.getBoundingClientRect();\n    var e = {\n      type: \"tm-navigate\",\n      navigateTo: toTiddlerTitle,\n      navigateFromTitle: self.getVariable(\"currentTiddler\"),\n      navigateFromNode: domTiddler,\n      navigateFromClientRect: { top: bounds.top, left: bounds.left, width: bounds.width, right: bounds.right, bottom: bounds.bottom, height: bounds.height\n      }\n    };\n    self.dispatchEvent(e);\n  }\n\n  function enhancedColorStyle(csscolor) {\n    var color = $tw.utils.parseCSSColor(csscolor);\n    var style = null;\n    if(color !== null) {\n      for(var i=0;i<3;i++) color[i] = Math.floor(240 + color[i] / 17);\n\n      style = \"border-color: \" + csscolor + \";\"\n            + \"background-color: rgb(\" + (color[0]).toString()+\",\"\n                                       + (color[1]).toString()+\",\"\n                                       + (color[2]).toString()+\");\";\n    }\n    return style;\n  }\n\n  // adapted from $tw.utils.error of $:/boot/boot.js\n  function dispError(message, title, subtitle) {\n    console.error($tw.node ? \"\\x1b[1;31m\" + message + \"\\x1b[0m\" : message);\n    if($tw.browser && !$tw.node) {\n        // Display an error message to the user\n        var dm = $tw.utils.domMaker,\n            heading = dm(\"h1\",{text: (title || \"Error with vis.js Timeline\")}),\n            prompt = dm(\"div\",{text: (subtitle || \"Please check the following:\"), \"class\": \"tc-error-prompt\"}),\n            message = dm(\"div\",{innerHTML: message, attributes: {style: \"text-align: left;\"}}),\n            button = dm(\"button\",{text: \"close\"}),\n            form = dm(\"form\",{children: [heading,prompt,message,button], \"class\": \"tc-error-form\", attributes: {style: \"background-color: rgb(75, 75, 255); border: 8px solid rgb(0, 0, 255);\"}});\n        document.body.insertBefore(form,document.body.firstChild);\n        form.addEventListener(\"submit\",function(event) {\n            document.body.removeChild(form);\n            event.preventDefault();\n            return false;\n        },true);\n        return null;\n    } else if(!$tw.browser) {\n        // Exit if we're under node.js\n        process.exit(1);\n    }\n  }\n\n  function setTiddlerField(tiddlerTitle, field, value) {\n     if(tiddlerTitle && field) {\n       var fields = {\n         title: tiddlerTitle\n       };\n       fields[field] = value;\n       var tiddler = $tw.wiki.getTiddler(tiddlerTitle, true);\n       $tw.wiki.addTiddler(new $tw.Tiddler(tiddler, fields));\n     }\n   }\n\n  exports.parseWidgetAttributes = parseWidgetAttributes;\n  exports.displayTiddler = displayTiddler;\n  exports.enhancedColorStyle = enhancedColorStyle;\n  exports.dispError = dispError;\n  exports.setTiddlerField = setTiddlerField;\n}\n());\n",
            "type": "application/javascript",
            "module-type": "library"
        },
        "$:/plugins/kixam/timeline/icon": {
            "title": "$:/plugins/kixam/timeline/icon",
            "tags": "$:/tags/Image",
            "text": "<svg height=\"22pt\" width=\"22pt\" viewBox=\"0 0 128 128\">\n<path fill-rule=\"evenodd\" d=\"m64 0 54.56 32v64l-54.56 32-54.56-32v-64zm-48.429 75.635c8.5524 1.5516 29.568 7.708 27.545 6.755-10.977-5.172-27.059-20.046-27.059-20.046l26.814-23.294s12.652-15.314 29.23-16.023c3.6806-.15747 13.92-7.5832 19.605-5.2303 4.0461 1.6746 7.6113 13.276 9.3244 19.035 4.6497 15.63 3.1019 46.52 3.1019 46.52s6.4391-.30692 7.0193 6.8629c.18694 2.3102-.0602 10.297-9.1531 10.615-28.973 1.01-61.939-6.115-86.429-25.195zm57.684-31.244a17.066 17.066 0 0 0 -17.073 17.073 17.066 17.066 0 0 0 17.073 17.063 17.066 17.066 0 0 0 17.063 -17.063 17.066 17.066 0 0 0 -17.063 -17.073zm4.6 17.455a5.3692 5.3692 0 0 1 5.3727 5.3636 5.3692 5.3692 0 0 1 -5.3727 5.3727 5.3692 5.3692 0 0 1 -5.3727 -5.3727 5.3692 5.3692 0 0 1 5.3727 -5.3636z\"/>\n</svg>\n"
        },
        "$:/plugins/kixam/timeline/styles.css": {
            "title": "$:/plugins/kixam/timeline/styles.css",
            "tags": "[[$:/tags/Stylesheet]]",
            "type": "text/css",
            "text": ".vis-item .vis-dot {\n  border-color: inherit;\n}\n\n.vis-item .vis-range {\n  background-color: #f0f0ff;\n}\n\n.vis-labelset .vis-label {\n  background-color: #fffff0;\n}\n\n.vis-labelset .vis-label .vis-inner {\n  font-weight: bold;\n  width: 100%;\n  text-align: center;\n}\n\n.visjstimeline-navpad {\n  position: relative;\n}\n\n.visjstimeline-navpad div, .visjstimeline-warning {\n  z-index: 9999;\n  -moz-user-select: none;\n}\n\n.visjstimeline-warning {\n  fill: #FFFFFF;\n  background-color: #EE0000;\n  box-shadow: 0 0 5px rgba(0, 0, 0, 0.75);\n  top: 15px;\n  right: 15px;\n  width: 34px;\n  height: 34px;\n  position: absolute;\n  display: inline-block;\n  cursor: pointer;\n}\n\n.visjstimeline-warning:hover {\n  background-color: #FF0000;\n}\n\n.visjstimeline-warning svg {\n  width: 32px;\n  height: 32px;\n  margin: 1px;\n}\n\n.item-icon svg, .item-icon img {\n  max-height: 14px;\n  max-width: 14px;\n}\n\n.group-icon svg, .group-icon img {\n  max-height: 16px;\n  max-width: 16px;\n}\n"
        },
        "$:/plugins/kixam/timeline/license": {
            "title": "$:/plugins/kixam/timeline/license",
            "text": "! [[BSD 2-clause simplified license|http://www.freebsd.org/copyright/freebsd-license.html]]\n```\nCopyright (c) 2015, kixam\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n# Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n# Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n```\n"
        },
        "$:/plugins/kixam/timeline/readme": {
            "title": "$:/plugins/kixam/timeline/readme",
            "text": "! vis.js Timeline\n\nA timeline plugin for [[TiddlyWiki|http://tiddlywiki.com]] 5, using [[vis.js|http://visjs.org]].\n\n---\n\nContinued from [[emkay's plugin|https://github.com/emkayonline/tw5visjs]].\n\nDepends on [[felixhayashi's vis.js plugin|https://github.com/felixhayashi/TW5-Vis.js]] and [[moment.js plugin|https://github.com/kixam/TW5-moment.js]], which are available, along with installation instructions, on the [[demo site|http://kixam.github.io/TW5-visjsTimeline]].\n"
        },
        "$:/plugins/kixam/timeline/usage": {
            "title": "$:/plugins/kixam/timeline/usage",
            "text": "\\define createSaveCloseTiddler(title,text)\n<$action-sendmessage $message=\"tm-new-tiddler\" title=\"$title$\" text=\"$text$\" />\n<$action-sendmessage $message=\"tm-save-tiddler\" $param=\"Draft of '$title$'\" />\n<$action-sendmessage $message=\"tm-close-tiddler\" $param=\"$title$\" />\n\\end\n\n\\define demoTiddlerContents(option)\nValue for option ''$option$'' : <$edit-text tag=input tiddler='$(optionValueTiddler)$'/>\n\n!!Result\n<$visjstimeline $option$={{$(optionValueTiddler)$}} />\n\\end\n\n\\define tryit(option,value:\"\")\n<$set name=optionValueTiddler value=\"$:/temp/visjstimeline-demo-option-$option$\">\n<$set name=optionDemoTiddler value=\"Testing option '$option$'\">\n<$button>\n<$macrocall $name=createSaveCloseTiddler title=<<optionValueTiddler>> text=\"$value$\" />\n<$macrocall $name=createSaveCloseTiddler title=<<optionDemoTiddler>> text=<<demoTiddlerContents \"$option$\">> />\n<$action-navigate $to=<<optionDemoTiddler>> />\nTry it!\n</$button>\n</$set>\n</$set>\n\\end\n\n!Introduction\n\nThis project is a direct continuation of [[emkay's plugin|https://github.com/emkayonline/tw5visjs]].\n\nThe `<$visjstimeline>` widget shows a set of tiddlers on a graphical timeline. The timeline is interactive and dynamic, and can be zoomed and moved around by dragging.\n\n!Content and Attributes\n\nA list of tiddlers is specified using a filter.\n\nEach matching tiddler is shown on the timeline using its specified start date and, if provided, end date fields. The start date defaults to the 'created' field.\n\n!! Valid date format on tiddlers\n* By default dates are parsed using the [[TiddlyWiki|http://tiddlywiki.com/#TiddlyWiki]] date parser (which will handle the `created` and `modified` fields)\n* An override date format can be specified.\n* This format will apply to both the start and end dates, `customTime`, as well as `timeline.start` and `timeline.end` fields if set manually.\n* Additionally the start date or end date field on a tiddler, or the `customTime` attribute, can be set to the word `now`: this will set the date in the timeline to the date at the time the timeline is displayed.\n* Finally, any date field can use `moment`'s [[relative date calculation functions|http://momentjs.com/docs/#/manipulating/add/]] `add` or `subtract`, overloading the provided format. For instance, if `persistent` option is used, one can manually set `timeline.start` field to `moment().subtract(2,days)`, which will result in the timeline start date to be 2 days before 'now', that is 2 days before the date when the timeline is rendered. The syntax `moment(2015-10-14).add(1,days)` would compute into one day after Wednesday, 14th October, 2015, that is, Thursday, 15th. In this particular case, it is advised to set `vis.js` option `moveable` to `false`, see this plugin's `config` option.\n\n!! Relevant tiddler fields\n|!Field|!Interpretation|\n| `caption` |Used to represent the tiddler instead of the `title`.|\n| `description` |Used instead of `caption` or `title` to render description text when mouse hovers over the item.|\n| `icon` |Link to a image tiddler that will be used as the item's icon.|\n| `color` |Used to render the corresponding item or group on the timeline.|\n| `timeline.start` and `timeline.end` |If the `persistent` attribute is present, used to initialize the start and end of the contained timeline x-axis, respectively. When in use, `persistent` option will use a temporary tiddler at `$:/temp/kixam/visjstimeline/persistent/<titleOfTiddlerContainingTimeline>`. Note that, if `vis.js` option `moveable` is set to `true`, which is the default, these fields at the temporary tiddler will be silently overwritten by this plugin whenever the user zooms or moves the timeline. You can also change them manually.|\n\n!! Attributes\n\nAll attributes are optional.\n\n|!Attribute|!Description|!Default value|! |\n| `filter` |The [[TiddlerFilter|http://tiddlywiki.com/#Filters]] used to generate the list of tiddlers to display.|`!is[system]`|<<tryit filter \"[all[tiddlers]tag[Group A]]\">>|\n| `startDateField` |A field on each tiddler that defines the start date of a tiddler in the timeline.|`created`|<<tryit startDateField modified>>|\n| `endDateField` |A field on each tiddler that defines the end date of a tiddler in the timeline.|//undefined//|<<tryit endDateField created>>|\n| `format` |The format for parsing the dates, using the moment.js [[Parse string+format|http://momentjs.com/docs/#/parsing/string-format/]]. If unset, uses [[TW5 date format|http://tiddlywiki.com/#DateFormat]].|//undefined//||\n| `tipFormat` |If present, the date format used to display the starting and ending dates in the tooltip boxes when mouse gets over an item. If unset, the dates are not displayed|//undefined//|<<tryit tipFormat \"YYYY-MM-DD HH:mm:ss\">>|\n| `groupField` |A field whose value will be used to group tiddlers on the timeline.|//undefined//|<<tryit groupField color>>|\n| `customTime` |A date at which a vertical bar will be shown on the timeline. Affected by `format`. It can be moved by the user, but the new position will not be saved.|//undefined//|<<tryit customTime \"20150619\">>|\n| `groupTags` |If `groupField` field is not used and if a filtered tiddler has a tag among the given [[Title List|http://tiddlywiki.com/#Title%20List]], this tag will be used as the item's group.|//undefined//|<<tryit groupTags \"[[Group A]]\">>|\n| `boxing` |If set to `static`, the containing box will be static. If set to `auto`, the timeline will dynamically adjust its height to the items to show.|`static`|<<tryit boxing auto>>|\n| `navpad` |If set, a navpad will be shown.|//undefined//|<<tryit navpad>>|\n| `config` |Title of a tiddler which contains configuration options for the timeline in [[JSON format|http://tiddlywiki.com/#JSONTiddlers]], as per [[vis.js documentation|http://visjs.org/docs/timeline/#Configuration_Options]].|//undefined//||\n| `persistent` |If set, the x-axis range will become persistent. Uses (creates, if needed) 2 fields of the tiddler containing the timeline, namely `timeline.start` and `timeline.end`.|//undefined//|<<tryit persistent>>|\n\n!!!Notes about the `config` attribute\n* for the sake of integration, not all the options are available, please see [[the whitelist|$:/plugins/kixam/timeline/validOptions]];\n* the `navpad` is not affected by options passed through this mechanism, except for these listed below the `whitelist` under the name `navbarReactOptions`;\n* if you create or change options in your config tiddler after the timeline was drawn, you may need to have it redrawn, e.g. by editing/canceling the tiddler containing the timeline, or by changing sidebar panel back and forth.\n\n!!!Notes about the `groupField` and `groupTags` attributes\n* if the `filter` finds tiddlers that cannot be grouped according to the criteria given by either of these attributes, these tiddlers will be shown in a dedicated generic group called `Global`\n* if a tiddler representing a tag is listed by the `groupTags` attribute and has any of the relevant tiddler fields listed in the previous section, they will be used to render the group in the group margin\n\nThe content of the `<$visjstimeline>` widget is ignored.\n\n! Example Usage\n\nShow all non-system tiddlers, using their created date as the start date:\n\n`<$visjstimeline/>`\n\nShow all Tiddlers with a name starting 'Tiddler', using the born and died fields with a custom format:\n\n`<$visjstimeline filter=\"[prefix[Tiddler]]\" startDateField=\"born\" endDateField=\"died\" format=\"YYYY MMM\"/>`\n"
        },
        "$:/plugins/kixam/timeline/validOptions": {
            "title": "$:/plugins/kixam/timeline/validOptions",
            "type": "application/json",
            "text": "{\n\t\"whitelist\": [\"align\",\"clickToUse\",\"end\",\"format\",\"hiddenDates\",\"margin\",\"max\",\"min\",\"moveable\",\"orientation\",\"showCurrentTime\",\"showMajorLabels\",\"showMinorLabels\",\"stack\",\"start\",\"timeAxis\",\"zoomable\",\"zoomMin\",\"zoomMax\"],\n\t\"navbarReactOptions\": [\"clickToUse\",\"max\",\"min\",\"zoomMin\",\"zoomMax\"]\n}\n"
        },
        "$:/plugins/kixam/timeline/widget.timeline.js": {
            "title": "$:/plugins/kixam/timeline/widget.timeline.js",
            "text": "/*\\\ntitle: $:/plugins/kixam/timeline/widget.timeline.js\ntype: application/javascript\nmodule-type: widget\n\n  A widget for displaying timelines using Vis.js.  http://visjs.org\n  Continued from emkay's plugin at https://github.com/emkayonline/tw5visjs\n\n  For full help see $:/plugins/kixam/timeline/help\n\n\\*/\n\n/*jslint node: true, browser: true */\n/*global $tw: false */\n\n(function() {\n  'use strict';\n\n  var Widget = require(\"$:/core/modules/widgets/widget.js\").widget;\n  var moment = require(\"$:/plugins/kixam/moment/moment.js\");\n  if(typeof window !== 'undefined' && typeof window.moment !== 'function') {\n    window.moment = moment;\n  }\n  var utils = require(\"$:/plugins/kixam/timeline/widget.utils.js\");\n  var vis = require(\"$:/plugins/felixhayashi/vis/vis.js\");\n\n  var TimelineWidget = function(parseTreeNode,options) {\n    Widget.call(this);\n    this.initialise(parseTreeNode,options);\n  };\n\n  TimelineWidget.prototype = new Widget();\n\n  TimelineWidget.prototype.render = function(parent,nextSibling) {\n    this.parentDomNode = parent;\n    this.computeAttributes();\n    this.options = {orientation: \"bottom\"};\n    this.tiddler = this.parentWidget;\n    while(this.tiddler.parentWidget !== undefined && this.tiddler.tiddlerTitle === undefined && this.tiddler.transcludeTitle === undefined) {\n      this.tiddler = this.tiddler.parentWidget;\n    }\n    this.tiddler = $tw.wiki.getTiddler(this.tiddler.tiddlerTitle || this.tiddler.transcludeTitle);\n    this.warningTiddlerTitle = \"$:/temp/visjstimeline/warning/\" + this.tiddler.fields.title;\n    this.persistentTiddlerTitle = \"$:/temp/visjstimeline/persistent/\" + this.tiddler.fields.title;\n    this.hasCustomTime = false;\n\n    var attrParseWorked = this.execute();\n    if (attrParseWorked === undefined) {\n      this.timelineHolder = $tw.utils.domMaker(\"div\",{attributes:{style: \"position: relative;\"}});\n      parent.insertBefore(this.timelineHolder,nextSibling);\n      this.domNodes.push(this.timelineHolder);\n\n      if(this.attributes[\"boxing\"] !== \"auto\") {\n        this.timelineHolder.style[\"height\"]=\"100%\";\n        // -- adapted from felixhayashi's tiddlymap in widget.map.js\n        this.sidebar = document.getElementsByClassName(\"tc-sidebar-scrollable\")[0];\n        this.isContainedInSidebar = (this.sidebar && this.sidebar.contains(this.parentDomNode));\n        if(this.isContainedInSidebar) {\n          this.parentDomNode.style[\"margin-top\"]=\"-14px\";\n          this.parentDomNode.style[\"padding-right\"]=\"2px\";\n        } else {\n          this.parentDomNode.style[\"height\"] = \"auto\";\n        }\n        parent.style[\"width\"] = this.getAttribute(\"width\", \"100%\");\n        this.handleResizeEvent = this.handleResizeEvent.bind(this);\n        window.addEventListener(\"resize\", this.handleResizeEvent, false);\n        this.handleResizeEvent();\n        // --\n        this.options[\"height\"] = \"100%\";\n      }\n\n      this.createWarningButton();\n\n      this.createTimeline();\n\n      if(this.attributes[\"navpad\"] !== undefined) {\n        this.options[\"orientation\"] = \"top\";\n      }\n      // default options must be set at this point, as we might add/change options from user through 'config'\n      this.updateTimeline();\n\n      if(this.attributes[\"navpad\"] !== undefined) {\n        this.createNavpad(); // must be created only after all options were processed\n                             // e.g. for clickToUse, we observe vis-overlay, which will not exist if option is not processed\n      }\n\n\n    } else {\n      utils.dispError(this.parseTreeNode.type+\": Unexpected attribute(s) \"+attrParseWorked.join(\", \"));\n      this.refresh = function() {}; // disable refresh of this as it won't work with incorrrect attributes\n    }\n  };\n\n\n  TimelineWidget.prototype.execute = function() {\n    var attrParseWorked = utils.parseWidgetAttributes(this,{\n           filter: { type: \"string\", defaultValue: \"[!is[system]]\"},\n           groupField: { type: \"string\", defaultValue: undefined},\n           startDateField: { type: \"string\", defaultValue: \"created\"},\n           endDateField:  { type: \"string\", defaultValue: undefined},\n           format:  { type: \"string\", defaultValue: undefined},\n           tipFormat:  { type: \"string\", defaultValue: undefined},\n           customTime:  { type: \"string\", defaultValue: undefined},\n           groupTags: {type: \"string\", defaultValue: undefined},\n           boxing: {type: \"string\", defaultValue: \"static\"},\n           navpad: {type: \"string\", defaultValue: undefined},\n           config: {type: \"string\", defaultValue: undefined},\n           persistent: {type: \"string\", defaultValue: undefined},\n           });\n\n    if ((attrParseWorked === undefined) && (this.filter)) {\n      this.compiledFilter = this.wiki.compileFilter(this.filter);\n    }\n\n    return attrParseWorked;\n  };\n\n  TimelineWidget.prototype.getTimepointList = function(changedTiddlers) {\n    var tiddlerList = [];\n    // process the filter into an array of tiddler titles\n    tiddlerList = this.compiledFilter.call(null, changedTiddlers, null);\n    // If filter is a list of tiddlers it will return tiddlers even if they are not in changed Tiddlers\n    if (changedTiddlers !== undefined) {\n      tiddlerList = tiddlerList.filter(function (e) { return changedTiddlers[e];});\n    }\n    var self = this;\n    var withoutDraftsList = tiddlerList.filter(function(optionTitle) {\n      var optionTiddler = self.wiki.getTiddler(optionTitle);\n      if (optionTiddler === undefined) {\n        // tiddler may not exist if list attribute provided to widget, so exclude\n        return true;\n      } else {\n        var isDraft = optionTiddler && optionTiddler.hasField(\"draft.of\");\n        return !isDraft;\n      }\n    });\n    return withoutDraftsList;\n  };\n  /*\n     Selectively refreshes the widget if needed. Returns true if the widget or any of its children needed re-rendering\n     */\n  TimelineWidget.prototype.refresh = function(changedTiddlers) {\n    var changedAttributes = this.computeAttributes();\n    if(changedAttributes.filter\n    || changedAttributes.startDateField\n    || changedAttributes.endDateField\n    || changedAttributes.tipFormat\n    || changedAttributes.groupField\n    || changedAttributes.customTime\n    || changedAttributes.groupTags\n    || changedAttributes.boxing\n    || changedAttributes.navpad\n    || changedAttributes.config) {\n      this.refreshSelf();\n      this.updateTimeline();\n      return true;\n    }\n    if (this.displayedTiddlers.some(function (e) { return changedTiddlers[e.id]; })) {\n      this.updateTimeline();\n      return true;\n    }\n    var anyRelevantChanges = this.getTimepointList(changedTiddlers);\n    if (anyRelevantChanges.length !== 0) {\n      this.updateTimeline();\n      return true;\n    }\n    this.handleResizeEvent();\n  };\n\n  TimelineWidget.prototype.createTimeline = function() {\n    var data = [];\n    this.timeline = new vis.Timeline(this.timelineHolder, data, this.options);\n\n    var self = this;\n    this.timeline.on('click', function(properties) {\n      // Check if background or a tiddler is selected\n      if (properties.item !== null) {\n        var toTiddlerTitle = properties.item;\n        utils.displayTiddler(self, toTiddlerTitle);\n      }\n      else if(properties.group !== null && properties.what === \"group-label\") {\n        var toTiddlerTitle = properties.group;\n        if($tw.wiki.getTiddler(toTiddlerTitle)) {\n          utils.displayTiddler(self, toTiddlerTitle);\n        }\n      }\n    });\n\n    if(this.attributes[\"persistent\"] !== undefined) {\n      // duplicate initial settings to working tiddler if it does not exist\n      var tiddler = $tw.wiki.getTiddler(this.persistentTiddlerTitle);\n      if(tiddler === undefined) {\n        var rawstart = this.tiddler.fields[\"timeline.start\"],\n            tstart = moment(dateFieldToDate(rawstart, this.format)),\n            rawend = this.tiddler.fields[\"timeline.end\"],\n            tend = moment(dateFieldToDate(rawend, this.format)),\n            fields = {title: this.persistentTiddlerTitle,\n                      text: \"Timeline in [[\" + this.tiddler.fields.title + \"]] starts from {{!!timeline.start}} and ends at {{!!timeline.end}}\"};\n        if(tstart.isValid() && tend.isValid() && tstart.isBefore(tend)) {\n          fields[\"timeline.start\"] = rawstart;\n          fields[\"timeline.end\"] = rawend;\n        }\n        $tw.wiki.addTiddler(new $tw.Tiddler(fields));\n      }\n\n      // apply saved x-axis range from the working tiddler\n      tiddler = $tw.wiki.getTiddler(this.persistentTiddlerTitle);\n      var start = moment(dateFieldToDate(tiddler.fields[\"timeline.start\"], this.format)),\n          end = moment(dateFieldToDate(tiddler.fields[\"timeline.end\"], this.format));\n      if(start.isValid() && end.isValid() && start.isBefore(end)) {\n        this.options.start = start.toDate();\n        this.options.end = end.toDate();\n      }\n\n      // monitor and save changes in x-axis range\n      this.writeRange = false;\n      this.handleRangeChanged = this.handleRangeChanged.bind(this);\n      this.timeline.on('rangechanged', this.handleRangeChanged);\n    }\n  };\n\n  TimelineWidget.prototype.handleRangeChanged = function(properties) {\n    if(properties.byUser || this.writeRange) {\n      var start = moment(properties.start);\n      var end = moment(properties.end);\n      if(start.isValid() && end.isValid()) {\n        utils.setTiddlerField(this.persistentTiddlerTitle, \"timeline.start\", start.format());\n        utils.setTiddlerField(this.persistentTiddlerTitle, \"timeline.end\", end.format());\n      }\n    }\n    this.writeRange = false;\n  }\n\n  // -- adapted from felixhayashi's tiddlymap in widget.map.js\n  TimelineWidget.prototype.handleResizeEvent = function(event) {\n    if(this.isContainedInSidebar) {\n      var windowHeight = window.innerHeight;\n      var canvasOffset = this.parentDomNode.getBoundingClientRect().top;\n      var distanceBottom = this.getAttribute(\"bottom-spacing\", \"0px\");\n      var calculatedHeight = (windowHeight - canvasOffset - (this.isContainedInSidebar?3:0)) + \"px\";\n      this.parentDomNode.style[\"height\"] = \"calc(\" + calculatedHeight + \" - \" + distanceBottom + \")\";\n    } else if(this.attributes[\"boxing\"] === \"auto\") {\n      this.parentDomNode.style[\"height\"] = \"auto\";\n    } else {\n      var height = this.getAttribute(\"height\");\n      this.parentDomNode.style[\"height\"] = (height ? height : \"300px\");\n    }\n    if(this.timeline) {\n      this.timeline.redraw(); // redraw timeline\n    }\n  };\n  // --\n\n  TimelineWidget.prototype.createWarningButton = function() {\n    var button = $tw.utils.domMaker(\"div\", {innerHTML: $tw.wiki.getTiddlerText(\"$:/core/images/warning\",\"Warning\"), class: \"visjstimeline-warning\", attributes: {title: \"Not all tiddlers could be rendered\",  style: \"visibility: hidden\"}});\n\n    this.timelineHolder.appendChild(button);\n    this.domNodes.push(button);\n\n    this.handleWarningClick = this.handleWarningClick.bind(this);\n    button.addEventListener(\"click\", this.handleWarningClick, false);\n  }\n\n  TimelineWidget.prototype.handleWarningClick = function(event) {\n    utils.displayTiddler(this, this.warningTiddlerTitle);\n  }\n\n  TimelineWidget.prototype.appendWarning = function(message) {\n    if($tw.wiki.getTiddler(this.warningTiddlerTitle) === undefined) {\n      var format = \"Using \";\n      if(this.format === undefined) {\n        format += \"[[TW5 date format|http://tiddlywiki.com/#DateFormat]]\";\n      } else {\n        format += \"[[moment.js format|http://momentjs.com/docs/#/parsing/string-format/]]: `\" + this.format + \"`\";\n      }\n      var fields = {title: this.warningTiddlerTitle, text: \"!!!Problems found while rendering `<$visjstimeline/>` in [[\"+this.tiddler.fields.title+\"]]\\n\\n\" + format + \"\\n\\n|!Tiddler|!Problem|!Result|\\n\"};\n      $tw.wiki.addTiddler(new $tw.Tiddler(fields));\n    }\n    utils.setTiddlerField(this.warningTiddlerTitle,\"text\", $tw.wiki.getTiddlerText(this.warningTiddlerTitle) + message + \"\\n\");\n    var button = this.timelineHolder.getElementsByClassName(\"visjstimeline-warning\")[0];\n    button.style[\"visibility\"] = \"visible\";\n  }\n\n  TimelineWidget.prototype.resetWarning = function() {\n    $tw.wiki.deleteTiddler(this.warningTiddlerTitle);\n    var button = this.timelineHolder.getElementsByClassName(\"visjstimeline-warning\")[0];\n    button.style[\"visibility\"] = \"hidden\";\n  }\n\n  TimelineWidget.prototype.createNavpad = function() {\n    var navpad = $tw.utils.domMaker(\"div\",{class: \"vis-navigation visjstimeline-navpad\"});\n\n    this.timelineHolder.className = \"vis-network\";\n    this.timelineHolder.appendChild(navpad);\n    this.domNodes.push(navpad);\n\n    navpad.appendChild($tw.utils.domMaker(\"div\",{attributes:{class: \"vis-button vis-up\", id: \"up\", style: \"visibility: hidden\"}}));\n    navpad.appendChild($tw.utils.domMaker(\"div\",{attributes:{class: \"vis-button vis-down\", id: \"down\", style: \"visibility: hidden\"}}));\n    navpad.appendChild($tw.utils.domMaker(\"div\",{attributes:{class: \"vis-button vis-left\", id: \"left\"}}));\n    navpad.appendChild($tw.utils.domMaker(\"div\",{attributes:{class: \"vis-button vis-right\", id: \"right\"}}));\n    navpad.appendChild($tw.utils.domMaker(\"div\",{attributes:{class: \"vis-button vis-zoomIn\", id: \"zoomIn\"}}));\n    navpad.appendChild($tw.utils.domMaker(\"div\",{attributes:{class: \"vis-button vis-zoomOut\", id: \"zoomOut\"}}));\n    navpad.appendChild($tw.utils.domMaker(\"div\",{attributes:{class: \"vis-button vis-zoomExtends\", id: \"zoomExtends\"}}));\n\n    this.handleNavpadClick = this.handleNavpadClick.bind(this);\n    for(var i=0; i<navpad.childNodes.length; i++) {\n      this.domNodes.push(navpad.childNodes[i]);\n      navpad.childNodes[i].addEventListener(\"click\", this.handleNavpadClick, false);\n    }\n\n    var panel = this.timelineHolder.getElementsByClassName(\"vis-panel vis-center\")[0];\n    var top = panel.getElementsByClassName(\"vis-shadow vis-top\")[0];\n    var bottom = panel.getElementsByClassName(\"vis-shadow vis-bottom\")[0];\n    var overlay = this.timelineHolder.getElementsByClassName(\"vis-overlay\")[0];\n\n    this.handleItemsVisibilityChanged = this.handleItemsVisibilityChanged.bind(this);\n    var self = this;\n    var observer = new MutationObserver(function(mutations) {\n      for(var i=0; i<mutations.length; i++) {\n        self.handleItemsVisibilityChanged(mutations[i]);\n      }});\n    observer.observe(top, {attributes: true, subtree: false});\n    observer.observe(bottom, {attributes: true, subtree: false});\n    if(overlay !== undefined) { // clickToUse === true\n      observer.observe(overlay, {attributes: true, subtree: false});\n      navpad.style[\"visibility\"] = \"hidden\";\n    }\n  }\n\n  TimelineWidget.prototype.handleItemsVisibilityChanged = function(mutation) {\n    if(mutation.attributeName === \"style\") {\n      if((' ' + mutation.target.className + ' ').indexOf(' vis-overlay ') > -1) {\n        // whole navpad visibility\n        var timeline = this.timelineHolder.getElementsByClassName(\"vis-timeline\")[0];\n        var navpad = this.timelineHolder.getElementsByClassName(\"navpad\")[0];\n        if(navpad !== undefined) {\n          navpad.style[\"visibility\"] = (mutation.target.style[\"display\"] === \"none\" ? \"visible\":\"hidden\");\n        }\n      } else {\n        // up and down buttons visibility\n        var cls = \"vis-button \" + ( (' ' + mutation.target.className + ' ').indexOf(' vis-top ') > -1 ? \"vis-up\":\"vis-down\" );\n        var button = this.timelineHolder.getElementsByClassName(cls)[0];\n        if(button !== undefined) {\n          button.style[\"visibility\"] = mutation.target.style[\"visibility\"];\n        }\n      }\n    }\n  }\n\n  TimelineWidget.prototype.handleNavpadClick = function(event) {\n    var range = this.timeline.getWindow();\n    var interval = range.end - range.start;\n    var ratio = 0.2; // horizontal movement\n    var step = 10; // vertical movement\n\n    var centerdiv = this.timelineHolder.getElementsByClassName(\"vis-panel vis-center\")[0];\n    var contentdiv = centerdiv.getElementsByClassName(\"vis-content\")[0];\n    this.writeRange = true; // handle persistence\n    switch (event.target.id) {\n      case \"up\":\n        centerdiv.getElementsByClassName(\"vis-shadow vis-bottom\")[0].style[\"visibility\"] = \"visible\";\n        contentdiv.style[\"top\"] = parseInt(contentdiv.style[\"top\"]) + step + \"px\";\n        if(parseInt(contentdiv.style[\"top\"]) >= 0) {\n          contentdiv.style[\"top\"] = \"0px\";\n          centerdiv.getElementsByClassName(\"vis-shadow vis-top\")[0].style[\"visibility\"] = \"hidden\";\n        }\n        break;\n      case \"down\":\n        centerdiv.getElementsByClassName(\"vis-shadow vis-top\")[0].style[\"visibility\"] = \"visible\";\n        contentdiv.style[\"top\"] = parseInt(contentdiv.style[\"top\"]) - step + \"px\";\n        if( Math.abs(parseInt(contentdiv.style[\"top\"])) > contentdiv.getBoundingClientRect().height - centerdiv.getBoundingClientRect().height ) {\n          contentdiv.style[\"top\"] = contentdiv.getBoundingClientRect().height - centerdiv.getBoundingClientRect().height;\n          centerdiv.getElementsByClassName(\"vis-shadow vis-bottom\")[0].style[\"visibility\"] = \"hidden\";\n        }\n        break;\n      case \"left\":\n        this.timeline.setWindow({\n          start: range.start.valueOf() - interval * ratio,\n          end  : range.end.valueOf()   - interval * ratio,\n        });\n        break;\n      case \"right\":\n        this.timeline.setWindow({\n          start: range.start.valueOf() + interval * ratio,\n          end  : range.end.valueOf()   + interval * ratio,\n        });\n        break;\n      case \"zoomIn\":\n        this.timeline.setWindow({\n          start: range.start.valueOf() + interval * ratio,\n          end  : range.end.valueOf()   - interval * ratio,\n        });\n        break;\n      case \"zoomOut\":\n        this.timeline.setWindow({\n          start: range.start.valueOf() - interval * ratio,\n          end  : range.end.valueOf()   + interval * ratio,\n        });\n        break;\n      case \"zoomExtends\":\n        this.timeline.fit();\n        break;\n      default:\n        this.dispError(\"No such navtab action: \" + action);\n    }\n  }\n\n  function dateFieldToDate(dateField, dateFormat) {\n    if(dateField === undefined) return;\n    dateField = dateField.trim();\n    var re = /moment\\([\"' ]*([^)\"']*)[\"' ]*\\)\\.(add|subtract)\\( *([^,]+) *,[\"' ]*([^)\"']+)[\"' ]*\\)/i;\n    if (re.test(dateField)) {\n      var res = re.exec(dateField),\n          def = res[1],\n          operation = res[2],\n          qty = parseInt(res[3]),\n          unit = res[4],\n          m = (def.trim() === \"\" ? moment() : moment(def));\n      if (operation === \"add\") {\n        m.add(qty, unit);\n      } else if(operation === \"subtract\"){\n        m.subtract(qty, unit);\n      }\n      else m = moment.invalid();\n      if (m.isValid()) {\n        return m.toDate();\n      }\n    }\n    else if (dateField === \"now\") {\n        return new Date();\n    }\n    else if (dateField !== \"\") {\n      if (dateFormat === undefined) {\n        return $tw.utils.parseDate(dateField);\n      } else {\n        var m = moment(dateField, dateFormat, true);\n        if (m.isValid()) {\n          return m.toDate();\n        }\n      }\n    }\n  }\n\n  function iconPrefix(icon, color, spanclass)\n  {\n    var text = \"\",\n        iconTiddler = $tw.wiki.getTiddler(icon);\n    if(iconTiddler !== undefined) {\n      text = \"</span>&nbsp;\";\n      var type = iconTiddler.fields.type || \"image/svg+xml\";\n      if(type === \"image/svg+xml\") {\n        text = iconTiddler.fields.text + text;\n      } else {\n        $tw.Wiki.parsers[type](type, iconTiddler.fields.text, iconTiddler.fields);\n        var obj  = $tw.Wiki.parsers.tree[0];\n        text = \"></\" + obj.tag + \">\" + text;\n        for(var k in obj.attributes) {\n          text = \" \" + k + \" = '\" + obj.attributes[k].value + \"'\" + text;\n        }\n        text = \"<\" + obj.tag + text;\n      }\n      text = \"<span class='\" + spanclass + \"'\" + (color?\" style='fill:\"+color+\"';\":\"\") + \">\" + text;\n    }\n    return text;\n  }\n\n  function addTimeData(self) {\n    return function(current, tiddlerName) {\n      var currentData = current.data;\n      var currentGroups = current.groups;\n      var currentErrors = current.errors;\n      var theTiddler = self.wiki.getTiddler(tiddlerName);\n      // tiddler may not exist if list attribute provided to widget\n      if (theTiddler !== undefined) {\n        var tiddlerStartDate = theTiddler.getFieldString(self.startDateField);\n        var startDate = dateFieldToDate(tiddlerStartDate, self.format);\n        if (!isNaN(startDate)) {\n          var caption = theTiddler.fields.caption || tiddlerName,\n              description = theTiddler.fields.description || caption,\n              color = theTiddler.fields.color || false,\n              style = \"border-color: \" + color + \";\" || \"\",\n              icon = theTiddler.fields.icon;\n          caption = iconPrefix(icon, color, \"item-icon\") + caption;\n          if(self.tipFormat !== undefined) {\n            description += \"<br><br>\" + self.startDateField + \": \" + moment(startDate).format(self.tipFormat);\n          }\n          var newTimepoint = {id: tiddlerName, content: caption, title: description, style: style, start: startDate, type: 'point'};\n          var tiddlerGroup = \"\";\n          if (self.groupField !== undefined) {\n            tiddlerGroup = theTiddler.getFieldString(self.groupField);\n          } else if(self.groupTags !== undefined) {\n            $tw.utils.each($tw.wiki.filterTiddlers(self.groupTags),\n              function(tag) {if(theTiddler.hasTag(tag)) tiddlerGroup = tag;});\n          }\n          if(self.groupTags !== undefined || self.groupField !== undefined) {\n            if (tiddlerGroup !== \"\") {\n              newTimepoint.group = tiddlerGroup;\n              currentGroups[tiddlerGroup] = true;\n            } else {\n              newTimepoint.group = \"Global\";\n              currentGroups.Global = true;\n            }\n          }\n          if (self.endDateField !== undefined ) {\n            var tiddlerEndDate = theTiddler.getFieldString(self.endDateField);\n            var endDate = dateFieldToDate(tiddlerEndDate, self.format);\n            if(!isNaN(endDate) && endDate < startDate) {\n              currentErrors.push(\"| [[\" + tiddlerName + \"]] |End date \\\"\" + tiddlerEndDate + \"\\\" (field `\" + self.endDateField + \"`) is before start date \\\"\" + tiddlerStartDate + \"\\\" (field `\" + self.startDateField + \"`)|Used start date as end date|\");\n              endDate = startDate;\n            }\n            else if(isNaN(endDate)) {\n              if(tiddlerEndDate === \"\") {\n                currentErrors.push(\"| [[\" + tiddlerName + \"]] |End date field `\" + self.endDateField + \"` is empty or does not exist|Used start date as end date|\");\n              } else {\n                currentErrors.push(\"| [[\" + tiddlerName + \"]] |Could not parse end date \\\"\" + tiddlerEndDate + \"\\\" from field `\" + self.endDateField + \"`|Used start date as end date|\");\n              }\n              endDate = startDate;\n            }\n            else if(self.tipFormat !== undefined) {\n              newTimepoint.title += \"<br>\" + self.endDateField + \": \" + moment(endDate).format(self.tipFormat);\n            }\n\n            newTimepoint.end = endDate;\n            if (newTimepoint.end.getTime() != newTimepoint.start.getTime()) {\n              newTimepoint.type = 'range';\n              if(theTiddler.getFieldString(\"color\") !== \"\") {\n                newTimepoint.style += \"border-width: 3px;\" + utils.enhancedColorStyle(theTiddler.getFieldString(\"color\"));\n              }\n            }\n          }\n          currentData.push(newTimepoint);\n        } else {\n          if(tiddlerStartDate === \"\") {\n            currentErrors.push(\"| [[\" + tiddlerName + \"]] |Start date field `\" + self.startDateField + \"` is empty or does not exist|Not rendered|\");\n          } else {\n            currentErrors.push(\"| [[\" + tiddlerName + \"]] |Could not parse start date \\\"\" + tiddlerStartDate + \"\\\" from field `\" + self.startDateField + \"`|Not rendered|\");\n          }\n        }\n      } else {\n        currentErrors.push(\"| [[\" + tiddlerName + \"]] |Tiddler was not found|Not rendered|\");\n      }\n      return {data: currentData, groups: currentGroups, errors: currentErrors};\n    };\n  }\n\n  TimelineWidget.prototype.updateTimeline = function() {\n    this.resetWarning();\n\n    var langprefix = \"$:/languages/\".length,\n        lang = $tw.wiki.getTiddlerText(\"$:/language\").substring(langprefix, langprefix + 2);\n    if(lang === \"zh\") {\n      // TW5 does not use standard codes for Chinese\n      var suffix = $tw.wiki.getTiddlerText(\"$:/language\");\n      suffix = suffix.substring(suffix.length-1);\n      if(suffix === \"s\") {\n        lang = \"zh-cn\"; //simplified\n      } else {\n        lang = \"zh-tw\"; //traditional\n      }\n    }\n    this.options[\"locale\"] = moment.locale([lang, \"en\"]);\n\n    var timepointList = this.getTimepointList();\n    var groups = {};\n    if(this.groupTags !== undefined) {\n      $tw.utils.each($tw.wiki.filterTiddlers(this.groupTags),\n        function(tag) {groups[tag] = false;});\n    }\n    var result = timepointList.reduce(addTimeData(this), {data: [], groups: groups, errors: []});\n    this.displayedTiddlers = result.data;\n    this.timeline.setItems(result.data);\n    if (this.customTime !== undefined) {\n      if(this.hasCustomTime) {\n        this.timeline.removeCustomTime();\n        this.hasCustomTime = false;\n      }\n      var d = dateFieldToDate(this.customTime, this.format);\n      if (d !== undefined) {\n        this.timeline.addCustomTime(d);\n        this.hasCustomTime = true;\n      }\n    }\n    // override default options with these provided by the user, if any\n    var config = $tw.wiki.getTiddlerData(this.attributes[\"config\"], {});\n    var whitelist = $tw.wiki.getTiddlerData(\"$:/plugins/kixam/timeline/validOptions\", {\"whitelist\":[]}).whitelist;\n    if(this.attributes[\"persistent\"] !== undefined) {\n      whitelist.start = undefined;\n      whitelist.end = undefined;\n    }\n    for(var opt in config) {\n      if(whitelist.indexOf(opt) > -1) this.options[opt] = config[opt];\n    }\n    this.timeline.setOptions(this.options);\n    if (Object.keys(result.groups).length !== 0) {\n      var theGroups = [];\n      for (var group in result.groups) {\n        if(result.groups[group]) {\n          if(group === \"Global\") {\n            theGroups.splice(0,0,{id: group,\n                             content: \"&mdash; Global &mdash;\",\n                               title: \"(Global)\",\n                               style: \"background-color:rgba(0,0,0,0); font-style:italic;\"});\n          } else {\n            theGroups.push({id: group, content: group, title: group});\n            var tiddler = $tw.wiki.getTiddler(group);\n            if(tiddler !== undefined) {\n              var icon = tiddler.fields.icon,\n                  color = tiddler.fields.color || false,\n                  caption = iconPrefix(icon, color, \"group-icon\") + \"<p>\" + (tiddler.fields.caption || group) + \"</p>\",\n                  description = tiddler.fields.description || tiddler.fields.caption || group;\n              if(color) {\n                theGroups[theGroups.length-1].style = \"border-width:3px; border-style:solid;\"\n                                                    + \"border-bottom-width:3px; border-bottom-style:solid;\"\n                                                    + utils.enhancedColorStyle(color);\n              }\n              theGroups[theGroups.length-1].content = caption;\n              theGroups[theGroups.length-1].title = description;\n            }\n          }\n        }\n      }\n      this.timeline.setGroups(theGroups);\n    }\n    for(var i=0; i<result.errors.length; i++) {\n      this.appendWarning(result.errors[i]);\n    }\n    if(this.attributes[\"persistent\"] === undefined) {\n      this.timeline.fit();\n    }\n  };\n\n  exports.visjstimeline = TimelineWidget;\n\n  }\n  ());\n",
            "type": "application/javascript",
            "module-type": "widget"
        }
    }
}